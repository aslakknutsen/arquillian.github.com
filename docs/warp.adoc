Arquillian Warp Documentation
=============================
Lukas Fryc <lfryc@redhat.com>
:toc:

== What is Warp?

Arquillian Warp fills the void between client-side and server-side testing.

Using Warp, you can initiate an HTTP request using a client-side testing tool such as WebDriver and, in the same request cycle, execute in-container server-side tests. This powerful combination lets you cover integration across client and server.

The Warp effectively removes a need for mocking and opens new possibilities for debugging.


== Where to Use Warp?

Warp allows you to know as little or as much of the application under test as you want.

=== Gray-box Testing

Initially, Warp can be used from any black-box testing tool (like HttpClient, REST client, Selenium WebDriver, etc.). But it allows to hook into server request lifecycle and verify what happens inside the box (referred to as white-box testing). That is why we identify Warp as gray-box testing framework.

____
Allows you to test on whole scale of gray from white to black.
____

=== Integration Testing

On a scale of granularity of a test, Warp fits the best integration level of testing with a overlap to functional testing. You can either test components, application API or functional behavior.

=== Technology Independence

No matter of client-side tool you use for emiting HTTP request or what server-side framework runs on a server, Warp allows you to assert and verify logic on a most appropriate place of client-server request lifecycle.

=== Use Cases

Using Warp is limited just by your imagination, as long as you have in mind facts we had described earlier.

Just to note some specific use cases, Warp can:

* send a payload to a server
* verify an incoming request
* assert a state of a server context
* verify that given event was fired during request processing
* verify a completed response
* send a payload to a client

=== Project Stage

The Warp is good fit for basically any stage of a project:

* prototyping (TDD)
* legacy projects
* issue reproduction
* debugging issue

Thanks to ability to bring a server arbitrary payload to a server and hook into server-lifecycle, we can use Warp in partially implemented projects. We needn't to have database layer implemented in order to test UI logic. This is especially useful for projects based on loosely coupled components (e.g. Java EE's CDI).

Since we can use Warp and start with white-box testing, we can reproduce the issue on the level of application's interface (issue reproduction). Then we can dive deeper into internals of an application, which will not only allow us to reveal how it works, but also debug a system and assert a correct behavior.

== Architecture

=== Lifecycle

In order to hook into client-to-server communication, Warp puts a proxy server between them as illustrated on a image bellow.


TODO diagram

This proxy observes request incoming from the client and then enhances the request with the payload required for server's inspection (processed reffered to as piggy-backing on the request).

Once the enhanced request enters a server, it is blocked by request filter and the description of inspection is registered in Arquillian system. The Warp's filter then handles the processing to the traditional request processing.

During a requst processing lifecycle, the Warp listens for appropriate callbacks and as a response, it can execute arbitrary actions which inspects a state of the request context.

To help with the full-featured verification, Warp's inspection process can leverage Arquillian's dependency injection system.

Once the request is processed by the server, leading into committing response, Warp can collect a result of inspection and enhance a built response to the client (again using piggy-backing method).

The Warp's proxy evaluates the response and either reports a failure (in case of server failure) or continues with execution of the test.

=== Focus

==== Cross-protocol

Warp currently supports only HTTP protocol, but conceptually it can be used with any protocol where we are able to intercept client-to-server communication on both, the client and the server.

==== Client-Side Testing Tools

Warp supports any client-side tools if you are using them in a way that requests can be intercepted (in a case of HTTP protocol, you need to communicate through a proxy instead of direct communication with a server).

The samples of such tools:

* URL#getResourceAsAStream()
* Apache HTTP Client
* Selenium WebDriver

Note: in order to use Warp, you should inject an @ArquillianResource URL, which points to the proxy automatically.

==== Frameworks

Warp currently focuses on frameworks based on Servlets API, but it provides special hooks and additiona support for:

* JSF
* JAX-RS (Rest)
* Spring MVC

== High-Level API

The Warp requires two inputs from the user:

* what activity should be done in order to trigger a request
* how the server processing should be inspected

This maps to the simplest possible high-level API:

----
Warp
	.initiate(Activity)
	.inspect(Inspection);
----

Note: the Warp may need to know what request should be inspected since the client may naturally fire more requests - thus this simple API will actually inject a first request (whatever it is). If you want to observe and inspect other particular request or you are dealing with instability, you should use 

== Server Inspection

== Dependency Injection

== Request Groups

== Request Observers

== Anonymous/Inner Classes

=== Serialization

=== Extraction

== Framework Extensions
